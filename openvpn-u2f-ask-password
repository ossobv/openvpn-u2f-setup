#!/usr/bin/env python3
import os
import subprocess
import sys
import time
from base64 import urlsafe_b64encode

import pyinotify  # python3-pyinotify
import json

try:
    import gi  # python3-gi (GObject for GTK+/GNOME)

    # "ValueError: Namespace Notify not available for version 0.8"
    gi.require_version('Notify', '0.7')  # hide version warning

    from gi.repository import Notify as GObjectNotify
except ImportError:
    GObjectNotify = None


class Notification:
    @classmethod
    def init(cls):
        if not hasattr(cls, '_init'):
            cls._init = GObjectNotify.init(os.path.basename(sys.argv[0]))

            for image_candidate in (
                    '/usr/share/icons/gnome/48x48/devices/network-vpn.png',):
                if os.path.isfile(image_candidate):
                    cls._image_path = image_candidate
                    break
            else:
                cls._image_path = 'dialog-warn'  # dialog-(information|error)

    def __init__(self, title, body):
        self._title = title
        self._body = body
        self._notification = None

        if GObjectNotify:
            self.init()
            self._notification = GObjectNotify.Notification.new(
                title, body, self._image_path)
            # self._notification.add_action('action_click', 'Reply', cb, None)
            self._notification.set_urgency(2)  # 0=low, 1=normal, 2=high
            self._notification.show()

        print('> [{}]\n> {}'.format(self._title, self._body))

    def show(self):
        if self._notification:
            self._notification.show()
        print('> [{}]\n> {}'.format(self._title, self._body))

    def update(self, body):
        self._body = body
        if self._notification:
            self._notification.set_property('body', body)
            self._notification.set_timeout(100)
            self._notification.show()
        print('> [{}]\n> {}'.format(self._title, self._body))


# Prefix myorigin with "pam://" because u2f-server is picky.
ORIGIN = 'pam://myorigin'

"""
From: https://systemd.io/PASSWORD_AGENTS/

> It is easy to write additional agents. The basic algorithm to follow looks
> like this:
>
> - Create an inotify watch on /run/systemd/ask-password, watch for
>   IN_CLOSE_WRITE|IN_MOVED_TO
>
> - Ignore all events on files in that directory that do not start with "ask."
>
> - As soon as a file named "ask.xxxx" shows up, read it. It's a simple .ini
>   file that may be parsed with the usual parsers. The xxxx suffix is
>   randomized.
>
> - Make sure to ignore unknown .ini file keys in those files, so that we can
>   easily extend the format later on.
>
> - You'll find the question to ask the user in the Message= field in the [Ask]
>   section. It is a single-line string in UTF-8, which might be
>   internationalized (by the party that originally asks the question, not by
>   the agent).
>
> - You'll find an icon name (following the XDG icon naming spec) to show next
>   to the message in the Icon= field in the [Ask] section
>
> - You'll find the PID of the client asking the question in the PID= field in
>   the [Ask] section (Before asking your question use kill(PID, 0) and ignore
>   the file if this returns ESRCH; there's no need to show the data of this
>   field but if you want to you may)
>
> - Echo= specifies whether the input should be obscured. If this field is
>   missing or is Echo=0, the input should not be shown.
>
> - The socket to send the response to is configured via Socket= in the [Ask]
>   section. It is a AF_UNIX/SOCK_DGRAM socket in the file system.
>
> - Ignore files where the time specified in the NotAfter= field in the [Ask]
>   section is in the past. The time is specified in usecs, and refers to the
>   CLOCK_MONOTONIC clock. If NotAfter= is 0, no such check should take place.
>
> - Make sure to hide a password query dialog as soon as a) the ask.xxxx file
>   is deleted, watch this with inotify. b) the NotAfter= time elapses, if it
>   is set != 0.

^^^^^^^-- FIXME

> - Access to the socket is restricted to privileged users. To acquire the
>   necessary privileges to send the answer back, consider using PolicyKit. In
>   fact, the GNOME agent we ship does that, and you may simply piggyback on
>   that, by executing "/usr/bin/pkexec /lib/systemd/systemd-reply-password 1
>   /path/to/socket" or "/usr/bin/pkexec /lib/systemd/systemd-reply-password 0
>   /path/to/socket" and writing the password to its standard input. Use ‘1' as
>   argument if a password was entered by the user, or ‘0' if the user canceled
>   the request.
>
> - If you do not want to use PK ensure to acquire the necessary privileges in
>   some other way and send a single datagram to the socket consisting of the
>   password string either prefixed with "+" or with "-" depending on whether
>   the password entry was successful or not. You may but don't have to include
>   a final NUL byte in your message.
"""


class Process:
    @staticmethod
    def getppid(pid):
        try:
            with open('/proc/{}/stat'.format(pid), 'rb') as fp:
                stat = fp.read().decode('ascii', 'replace').split(' ')
        except OSError:  # FileNotFoundError? PermissionDenied?
            return 1
        # pid (comm) state ppid pgrp ... (see: man 5 proc)
        for i in range(1, len(stat)):
            if stat[i].endswith(')'):
                break
        else:
            return 1
        # i is now 1 except when there is a space in comm
        return int(stat[i + 2])

    @staticmethod
    def getcwd(pid):
        try:
            return os.readlink('/proc/{}/cwd'.format(pid))
        except OSError:  # FileNotFoundError? PermissionDenied?
            return ''

    @staticmethod
    def getexe(pid):
        try:
            return os.readlink('/proc/{}/exe'.format(pid))
        except OSError:  # FileNotFoundError? PermissionDenied?
            return ''

    @staticmethod
    def getcmdline(pid):
        try:
            with open('/proc/{}/cmdline'.format(pid), 'rb') as fp:
                return fp.read().decode('ascii', 'replace').split('\0')
        except OSError:  # FileNotFoundError? PermissionDenied?
            return []

    @classmethod
    def from_pid(cls, pid):
        try:
            os.kill(pid, 0)
        except OSError as e:
            if e.args[0] == 3:  # ESRCH [Errno 3] No such process
                print('pid {} is gone at {}'.format(pid, e))
                return None
            elif e.args[0] == 1:  # ENOPERM
                pass
        return cls(pid)

    def __init__(self, pid):
        self.pid = pid
        self.exe = self.getexe(pid)

        # Is the password request made through systemd-ask-password,
        # then fetch the parent process.
        # > /bin/systemd-ask-password --echo --icon network-vpn "Enter ...:"
        if self.exe == '/bin/systemd-ask-password':
            ppid = self.getppid(pid)
            if ppid != 1:
                pid = ppid
                self.pid = pid
                self.exe = self.getexe(pid)

    @property
    def cwd(self):
        return self.getcwd(self.pid)

    @property
    def cmdline(self):
        return self.getcmdline(self.pid)

    def __repr__(self):
        return '<Process({}, {}>'.format(self.pid, self.exe)


class EventHandler(pyinotify.ProcessEvent):
    def process_IN_CLOSE_WRITE(self, event):
        """
        event = <Event cookie=688867 dir=False mask=0x80 maskname=IN_MOVED_TO
          name=ask.rCEVu1 path=/run/systemd/ask-password
          pathname=/run/systemd/ask-password/ask.rCEVu1 wd=1 >
        event.pathname = /run/systemd/ask-password/ask.rCEVu1
        """
        # print(event)
        self._new_file(event.pathname)

    def process_IN_MOVED_TO(self, event):
        """
        event = <Event cookie=688867 dir=False mask=0x80 maskname=IN_MOVED_TO
          name=ask.rCEVu1 path=/run/systemd/ask-password
          pathname=/run/systemd/ask-password/ask.rCEVu1 wd=1 >
        event.pathname = /run/systemd/ask-password/ask.rCEVu1
        """
        # print(event)
        self._new_file(event.pathname)

    def _new_file(self, pathname):
        if os.path.basename(pathname).startswith('ask.'):
            try:
                with open(pathname, 'r') as fp:
                    self._on_ini(fp.read())
            except FileNotFoundError:
                print('file is now gone', pathname)
            except StopIteration:
                print('we will not handle this file', pathname)

    def _on_ini(self, inifile):
        """
        [Ask]
        PID=1285316
        Socket=/run/systemd/ask-password/sck.df96c35fda1a42ca
        AcceptCached=0
        Echo=1
        NotAfter=1974186814503
        Message=Enter Auth Username:
        Icon=network-vpn
        """
        lines = inifile.split('\n')
        header = lines[0][1:-1]
        vals = dict(i.split('=', 1) for i in lines[1:] if i)

        process = Process.from_pid(int(vals['PID']))
        if process and process.exe == '/usr/sbin/openvpn' and header == 'Ask':
            self._on_openvpn_ask(process, vals)

    def _get_config_filename_from_openvpn_process(self, process):
        cmdline = process.cmdline
        config = None
        try:
            idx = cmdline.index('--config')
            config = cmdline[idx + 1]
        except (IndexError, ValueError):
            # > If --config file is the only option to the openvpn
            # > command, the --config can be removed, and the command can
            # > be given as openvpn file
            if len(cmdline) == 2:
                config = cmdline[1]
        if config and config[0] != '/':
            config = os.path.join(process.cwd, config)
        assert os.path.isfile(config)
        return config

    def _get_u2f_keyhandle_from_openvpn_config(self, config):
        """
        Assume config is .../<VPN>.conf and .../<VPN>/keyhandle.dat exists.
        """
        assert config and config.endswith('.conf'), config
        with open(os.path.join(config[0:-5], 'keyhandle.dat')) as fp:
            return fp.read().strip()

    def _make_challenge_request(self, keyhandle):
        # Make it an exact int and no padding of other stuff.
        # Must be 32 bytes in total, so we pad before challenging.
        timestamp = str(int(time.time()))
        assert len(timestamp) == 10, timestamp
        assert all(i in '0123456789' for i in timestamp), timestamp
        b64challenge = (
            urlsafe_b64encode(
                (timestamp + 'Z' + timestamp + 'Z' + timestamp)
                .encode('ascii'))
            .decode('ascii').replace('=', ''))

        # Create request to pass to u2f-host. Pretend we got this from
        # u2f-server -a authenticate.
        request = (
            f'{{"keyHandle": "{keyhandle}", "version": "U2F_V2", '
            f'"challenge": "{b64challenge}", "appId": "myappid"}}')
        return timestamp, request

    def _make_challenge_response(self, vpn_name, keyhandle):
        # Do global (GUI?) notification.
        note = Notification(
            'OpenVPN {} U2F key request'.format(vpn_name),
            ('Please insert your hardware token for extra authentication. '
             'When it blinks, touch the button.'))

        #t0 = time.time()
        while True:
            t1 = time.time()
            # The request is valid for a very short while, so we'll need
            # a timeout on the process.
            timestamp, request = self._make_challenge_request(keyhandle)
            try:
                ret = subprocess.run(
                    ['/usr/bin/u2f-host', '-a', 'authenticate', '-o', ORIGIN],
                    input=request.encode('ascii'), stdout=subprocess.PIPE,
                    timeout=6)  # short timeout!
            except subprocess.TimeoutExpired:
                pass
            else:
                if ret.returncode == 0:
                    out = ret.stdout.decode('ascii')
                    break

            # FIXME: Wait for ???s right now..
            # We should wait until the file disappears (or is too old)
            # instead..
            #if (time.time() - t0) > 30:
            #    note.update('TIMEOUT. Too slow!')
            #    raise StopIteration()
            if (time.time() - t1) < 0.3:
                time.sleep(1)
            note.show()

        # If you were to feed the 'out' JSON to u2f-server -a authenticate,
        # it should be happy.
        # {"signatureData": "AQAA..",
        #  "clientData": "eyAiY2hhb...",
        #  "keyHandle": "SnVVgZR18w..."}
        # print('JSON:', out)

        # But, because we want minimal data sent over the username and
        # password fields, we'll send only our timestamp and the signature.
        jsdec = json.loads(out)
        signature = jsdec['signatureData']
        note.update('PRESSED. Thank you!')
        return timestamp, signature

    def _on_openvpn_ask(self, process, vals):
        config = self._get_config_filename_from_openvpn_process(process)
        keyhandle = self._get_u2f_keyhandle_from_openvpn_config(config)
        message = vals.get('Message').strip().lower()

        if message == 'enter auth username:':
            self._respond(vals['Socket'], keyhandle)
        elif message == 'enter auth password:':
            # Call upon work from the U2F token.
            vpn_name = os.path.basename(config).rsplit('.', 1)[0]
            timestamp, response = self._make_challenge_response(
                vpn_name, keyhandle)
            self._respond(vals['Socket'], '{}/{}'.format(timestamp, response))
        else:
            assert False, 'Unexpected message: {}'.format(vals)

    def _respond(self, socket, response):
        subprocess.run(
            ['/usr/bin/pkexec', '/lib/systemd/systemd-reply-password',
             '1', socket],
            input=response.encode('ascii'))
        print('responded with', response)


# Setup:
wm = pyinotify.WatchManager()
handler = EventHandler()
notifier = pyinotify.Notifier(wm, handler)
mask = pyinotify.IN_CLOSE_WRITE | pyinotify.IN_MOVED_TO
wm.add_watch('/run/systemd/ask-password', mask)

# Read/handle existing files first?
fs = os.listdir('/run/systemd/ask-password')
fs = [i for i in fs if i.startswith('ask.')]
for filename in fs:
    handler._new_file(os.path.join('/run/systemd/ask-password', filename))

# Infinite loop time?
notifier.loop()

# vim: set ts=8 sw=4 sts=4 et ai:
