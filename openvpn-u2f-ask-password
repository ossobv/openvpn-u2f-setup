#!/usr/bin/env python3
# openvpn-u2f-setup/openvpn-u2f-ask-password -- send U2F auth to OpenVPN server
# Copyright (C) 2021, Walter Doekes, OSSO B.V.
#
# This file is part of openvpn-u2f-setup. It is free software: you can
# redistribute it and/or modify it under the terms of the GNU General
# Public License as published by the Free Software Foundation, version 3
# or any later version.
#
# For documentation, sources and the full license, go to:
# https://github.com/ossobv/openvpn-u2f-setup
#
# This script needs to be installed as a daemon on your system so it
# can handle OpenVPN password requests through SystemD. Use the provided
# openvpn-u2f-ask-password.service file.

import json
import os
import subprocess
import sys
import time
from base64 import urlsafe_b64encode

import pyinotify  # python3-pyinotify

try:
    import gi  # python3-gi (GObject for GTK+/GNOME)

    # "ValueError: Namespace Notify not available for version 0.8"
    gi.require_version('Notify', '0.7')  # hide version warning

    from gi.repository import Notify as GObjectNotify
except ImportError:
    GObjectNotify = None

# Prefix myorigin with "pam://" because u2f-server is picky.
ORIGIN = 'pam://myorigin'


class Notification:
    """
    GNOME notification class with stdout fallback.

    Used to notify GUI users that action needs to be taken.
    """
    @classmethod
    def init(cls):
        if not hasattr(cls, '_init'):
            cls._init = GObjectNotify.init(os.path.basename(sys.argv[0]))

            for image_candidate in (
                    '/usr/share/icons/gnome/48x48/devices/network-vpn.png',):
                if os.path.isfile(image_candidate):
                    cls._image_path = image_candidate
                    break
            else:
                cls._image_path = 'dialog-warn'  # dialog-(information|error)

    def __init__(self, title, body):
        self._title = title
        self._body = body
        self._notification = None

        if GObjectNotify:
            self.init()
            self._notification = GObjectNotify.Notification.new(
                title, body, self._image_path)
            # self._notification.add_action('action_click', 'Reply', cb, None)
            self._notification.set_urgency(2)  # 0=low, 1=normal, 2=high
            self._notification.show()

        print('> [{}]\n> {}'.format(self._title, self._body))

    def show(self):
        if self._notification:
            self._notification.show()
        print('> [{}]\n> {}'.format(self._title, self._body))

    def update(self, body):
        self._body = body
        if self._notification:
            self._notification.set_property('body', body)
            self._notification.set_timeout(100)
            self._notification.show()
        print('> [{}]\n> {}'.format(self._title, self._body))


class Process:
    """
    Process helper; reads interesting stuff from /proc/PID.

    Used to detect which (openvpn) process is requesting a password.
    """
    @staticmethod
    def getppid(pid):
        try:
            with open('/proc/{}/stat'.format(pid), 'rb') as fp:
                stat = fp.read().decode('ascii', 'replace').split(' ')
        except OSError:  # FileNotFoundError? PermissionDenied?
            return 1
        # pid (comm) state ppid pgrp ... (see: man 5 proc)
        for i in range(1, len(stat)):
            if stat[i].endswith(')'):
                break
        else:
            return 1
        # i is now 1 except when there is a space in comm
        return int(stat[i + 2])

    @staticmethod
    def getcwd(pid):
        try:
            return os.readlink('/proc/{}/cwd'.format(pid))
        except OSError:  # FileNotFoundError? PermissionDenied?
            return ''

    @staticmethod
    def getexe(pid):
        try:
            return os.readlink('/proc/{}/exe'.format(pid))
        except OSError:  # FileNotFoundError? PermissionDenied?
            return ''

    @staticmethod
    def getcmdline(pid):
        try:
            with open('/proc/{}/cmdline'.format(pid), 'rb') as fp:
                return fp.read().decode('ascii', 'replace').split('\0')
        except OSError:  # FileNotFoundError? PermissionDenied?
            return []

    @classmethod
    def from_pid(cls, pid):
        try:
            os.kill(pid, 0)
        except OSError as e:
            if e.args[0] == 3:  # ESRCH [Errno 3] No such process
                print('pid {} is gone at {}'.format(pid, e))
                return None
            elif e.args[0] == 1:  # ENOPERM
                pass
        return cls(pid)

    def __init__(self, pid):
        self.pid = pid
        self.exe = self.getexe(pid)

        # Is the password request made through systemd-ask-password,
        # then fetch the parent process.
        # > /bin/systemd-ask-password --echo --icon network-vpn "Enter ...:"
        if self.exe == '/bin/systemd-ask-password':
            ppid = self.getppid(pid)
            if ppid != 1:
                pid = ppid
                self.pid = pid
                self.exe = self.getexe(pid)

    @property
    def cwd(self):
        return self.getcwd(self.pid)

    @property
    def cmdline(self):
        return self.getcmdline(self.pid)

    def __repr__(self):
        return '<Process({}, {}>'.format(self.pid, self.exe)


class AskPassword:
    """
    Base AskPassword class, reusable if we wanted.

    Subclasses need to implement handle().
    """
    def __init__(self, passfile, header, values, process):
        self._passfile = passfile
        self._header = header
        self._values = values
        self._process = process
        self._not_after = int(self._values.get('NotAfter', 0)) / 1000000.0

    def is_valid(self):
        # print('DEBUG: isfile {} AND {} > {}'.format(
        #     os.path.isfile(self._passfile), self._not_after,
        #     time.clock_gettime(time.CLOCK_MONOTONIC)))
        return (
            os.path.isfile(self._passfile) and
            (not self._not_after
                or self._not_after > time.clock_gettime(time.CLOCK_MONOTONIC)))

    def respond(self, response):
        subprocess.run(
            ['/usr/bin/pkexec', '/lib/systemd/systemd-reply-password',
             '1', self._values['Socket']],
            input=response.encode('ascii'))
        print('DEBUG: response to {!r}: {}'.format(
            self._values.get('Message'),
            (response if len(response) <= 16
             else '{}...'.format(response[0:16]))))

    def handle(self):
        raise NotImplementedError()


class AskPasswordOpenVpnU2f(AskPassword):
    """
    OpenVpnU2f specific AskPassword class.

    Called for usernames and passwords. Responds with keyhandle and
    (when U2F device is touched) with signed response.
    """
    @staticmethod
    def _get_config_filename_from_openvpn_process(process):
        cmdline = process.cmdline
        config = None
        try:
            idx = cmdline.index('--config')
            config = cmdline[idx + 1]
        except (IndexError, ValueError):
            # > If --config file is the only option to the openvpn
            # > command, the --config can be removed, and the command can
            # > be given as openvpn file
            if len(cmdline) == 2:
                config = cmdline[1]
        if config and config[0] != '/':
            config = os.path.join(process.cwd, config)
        assert os.path.isfile(config)
        return config

    @staticmethod
    def _get_u2f_keyhandle_from_openvpn_config(config):
        """
        Assume config is .../<VPN>.conf and .../<VPN>/keyhandle.dat exists.
        """
        assert config and config.endswith('.conf'), config
        with open(os.path.join(config[0:-5], 'keyhandle.dat')) as fp:
            return fp.read().strip()

    @staticmethod
    def _make_challenge_request(keyhandle):
        # Make it an exact int and no padding of other stuff.
        # Must be 32 bytes in total, so we pad before challenging.
        timestamp = str(int(time.time()))
        assert len(timestamp) == 10, timestamp
        assert all(i in '0123456789' for i in timestamp), timestamp
        b64challenge = (
            urlsafe_b64encode(
                (timestamp + 'Z' + timestamp + 'Z' + timestamp)
                .encode('ascii'))
            .decode('ascii').replace('=', ''))

        # Create request to pass to u2f-host. Pretend we got this from
        # u2f-server -a authenticate.
        request = (
            f'{{"keyHandle": "{keyhandle}", "version": "U2F_V2", '
            f'"challenge": "{b64challenge}", "appId": "myappid"}}')
        return timestamp, request

    def handle(self):
        config = self._get_config_filename_from_openvpn_process(self._process)
        keyhandle = self._get_u2f_keyhandle_from_openvpn_config(config)
        message = self._values.get('Message').strip().lower()

        if message == 'enter auth username:':
            self.respond(keyhandle)
        elif message == 'enter auth password:':
            # Call upon work from the U2F token.
            vpn_name = os.path.basename(config).rsplit('.', 1)[0]
            timestamp, response = self._make_challenge_response(
                vpn_name, keyhandle)
            if timestamp and response:
                self.respond('{}/{}'.format(timestamp, response))
        else:
            assert False, 'Unexpected message: {}'.format(self._values)

    def _make_challenge_response(self, vpn_name, keyhandle):
        # Do global (GUI?) notification.
        note = Notification(
            'OpenVPN {} U2F key request'.format(vpn_name),
            ('Please insert your hardware token for extra authentication. '
             'When it blinks, touch the button.'))

        t0 = time.time()
        while True:
            if not self.is_valid():
                note.update('TIMEOUT. Too slow!')
                return None, None

            # The request is valid for a very short while, so we'll need
            # a timeout on the process.
            timeout = 6  # MUST be lower than $timedelta max in openvpn-verify
            timestamp, request = self._make_challenge_request(keyhandle)
            t1 = time.time()
            try:
                ret = subprocess.run(
                    ['/usr/bin/u2f-host', '-a', 'authenticate', '-o', ORIGIN],
                    input=request.encode('ascii'), stdout=subprocess.PIPE,
                    timeout=timeout)  # short timeout in seconds
            except subprocess.TimeoutExpired:
                pass
            else:
                if ret.returncode == 0:
                    out = ret.stdout.decode('ascii')
                    break

            # XXX: After 300s (5mins) we abort. At this point you should
            # have your key. If you really want to log in. Restart the
            # OpenVPN client.
            if (time.time() - t0) > 300:
                note.update('TIMEOUT. Too slow!')
                return None, None

            # Sleep a short while if starting u2f-host failed quickly.
            if (time.time() - t1) < 0.3:
                time.sleep(1)

            note.show()

        # If you were to feed the 'out' JSON to u2f-server -a authenticate,
        # it should be happy.
        # {"signatureData": "AQAA..",
        #  "clientData": "eyAiY2hhb...",
        #  "keyHandle": "SnVVgZR18w..."}
        # print('JSON:', out)

        # But, because we want minimal data sent over the username and
        # password fields, we'll send only our timestamp and the signature.
        # We'll recreate the JSON found above on the server side.
        jsdec = json.loads(out)
        signature = jsdec['signatureData']
        note.update('PRESSED. Thank you!')
        return timestamp, signature


class AskPasswordHandler(pyinotify.ProcessEvent):
    def process_IN_CLOSE_WRITE(self, event):
        """
        event = <Event cookie=688867 dir=False mask=0x80 maskname=IN_MOVED_TO
          name=ask.rCEVu1 path=/run/systemd/ask-password
          pathname=/run/systemd/ask-password/ask.rCEVu1 wd=1 >
        event.pathname = /run/systemd/ask-password/ask.rCEVu1
        """
        # print(event)
        if os.path.basename(event.pathname).startswith('ask.'):
            self.handle_askfile(event.pathname)

    def process_IN_MOVED_TO(self, event):
        """
        event = <Event cookie=688867 dir=False mask=0x80 maskname=IN_MOVED_TO
          name=ask.rCEVu1 path=/run/systemd/ask-password
          pathname=/run/systemd/ask-password/ask.rCEVu1 wd=1 >
        event.pathname = /run/systemd/ask-password/ask.rCEVu1
        """
        # print(event)
        if os.path.basename(event.pathname).startswith('ask.'):
            self.handle_askfile(event.pathname)

    def handle_askfile(self, pathname):
        try:
            with open(pathname, 'r') as fp:
                data = fp.read()
        except FileNotFoundError:
            print('DEBUG: file is now gone', pathname)
        else:
            self._handle_inifile(pathname, data)

    def _handle_inifile(self, filename, inifile):
        """
        [Ask]
        PID=1285316
        Socket=/run/systemd/ask-password/sck.df96c35fda1a42ca
        AcceptCached=0
        Echo=1
        NotAfter=1974186814503
        Message=Enter Auth Username:
        Icon=network-vpn
        """
        lines = inifile.split('\n')
        header = lines[0][1:-1]
        vals = dict(i.split('=', 1) for i in lines[1:] if i)

        process = Process.from_pid(int(vals['PID']))
        if process and process.exe == '/usr/sbin/openvpn' and header == 'Ask':
            ask = AskPasswordOpenVpnU2f(filename, header, vals, process)
            ask.handle()
        else:
            # Ignore. This password request is not for us.
            pass


"""
From https://systemd.io/PASSWORD_AGENTS/ fetched on 2021-01-29.

> It is easy to write additional agents. The basic algorithm to follow looks
> like this:
>
> - Create an inotify watch on /run/systemd/ask-password, watch for
>   IN_CLOSE_WRITE|IN_MOVED_TO
>
> - Ignore all events on files in that directory that do not start with "ask."
>
> - As soon as a file named "ask.xxxx" shows up, read it. It's a simple .ini
>   file that may be parsed with the usual parsers. The xxxx suffix is
>   randomized.
>
> - Make sure to ignore unknown .ini file keys in those files, so that we can
>   easily extend the format later on.
>
> - You'll find the question to ask the user in the Message= field in the [Ask]
>   section. It is a single-line string in UTF-8, which might be
>   internationalized (by the party that originally asks the question, not by
>   the agent).
>
> - You'll find an icon name (following the XDG icon naming spec) to show next
>   to the message in the Icon= field in the [Ask] section
>
> - You'll find the PID of the client asking the question in the PID= field in
>   the [Ask] section (Before asking your question use kill(PID, 0) and ignore
>   the file if this returns ESRCH; there's no need to show the data of this
>   field but if you want to you may)
>
> - Echo= specifies whether the input should be obscured. If this field is
>   missing or is Echo=0, the input should not be shown.
>
> - The socket to send the response to is configured via Socket= in the [Ask]
>   section. It is a AF_UNIX/SOCK_DGRAM socket in the file system.
>
> - Ignore files where the time specified in the NotAfter= field in the [Ask]
>   section is in the past. The time is specified in usecs, and refers to the
>   CLOCK_MONOTONIC clock. If NotAfter= is 0, no such check should take place.
>
> - Make sure to hide a password query dialog as soon as a) the ask.xxxx file
>   is deleted, watch this with inotify. b) the NotAfter= time elapses, if it
>   is set != 0.
>
> - Access to the socket is restricted to privileged users. To acquire the
>   necessary privileges to send the answer back, consider using PolicyKit. In
>   fact, the GNOME agent we ship does that, and you may simply piggyback on
>   that, by executing "/usr/bin/pkexec /lib/systemd/systemd-reply-password 1
>   /path/to/socket" or "/usr/bin/pkexec /lib/systemd/systemd-reply-password 0
>   /path/to/socket" and writing the password to its standard input. Use ‘1' as
>   argument if a password was entered by the user, or ‘0' if the user canceled
>   the request.
>
> - If you do not want to use PK ensure to acquire the necessary privileges in
>   some other way and send a single datagram to the socket consisting of the
>   password string either prefixed with "+" or with "-" depending on whether
>   the password entry was successful or not. You may but don't have to include
>   a final NUL byte in your message.
"""
ASK_PASSWORD_DIRECTORY = '/run/systemd/ask-password'
wm = pyinotify.WatchManager()
handler = AskPasswordHandler()
notifier = pyinotify.Notifier(wm, handler)
mask = pyinotify.IN_CLOSE_WRITE | pyinotify.IN_MOVED_TO
wm.add_watch(ASK_PASSWORD_DIRECTORY, mask)

# Read/handle already existing files.. just in case.
fs = os.listdir('/run/systemd/ask-password')
fs = [i for i in fs if i.startswith('ask.')]
for filename in fs:
    handler.handle_askfile(os.path.join('/run/systemd/ask-password', filename))

# Infinite loop time.
print('Started {}, listening in /run/systemd/ask-password'.format(sys.argv[0]))
notifier.loop()

# vim: set ts=8 sw=4 sts=4 et ai:
